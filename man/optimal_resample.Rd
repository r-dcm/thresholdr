% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimal-resample.R
\name{optimal_resample}
\alias{optimal_resample}
\title{Use resampling to estimate an optimal probability threshold}
\usage{
optimal_resample(
  estimates,
  optimal_method,
  samples = 1000,
  weight_by = NULL,
  comp_thresholds = NULL,
  metrics = NULL
)
}
\arguments{
\item{estimates}{A vector of probabilities.}

\item{optimal_method}{The method for estimating the optimal threshold. One of
"youden", "topleft".}

\item{samples}{The number of samples of generated true values to create.}

\item{weight_by}{Optional. If provided, must be a class probability metric
from \link[yardstick:yardstick-package]{yardstick} used to weight the optimal
threshold from each resample when calculate the overall optimal threshold
(see Details below). If \code{NULL} (the default), all resamples are weighted
equally.}

\item{comp_thresholds}{Additional threshold values to evaluate against the
average optimal threshold (e.g., to compare the optimal threshold to a
competing threshold such as 0.5). If \code{NULL} (the default), no additional
thresholds are included in the performance evaluation.}

\item{metrics}{Either \code{NULL} or a \code{\link[yardstick:metric_set]{yardstick::metric_set()}} with a list of
performance metrics to calculate. The metrics should all be oriented
towards hard class predictions (e.g., \code{\link[yardstick:sens]{yardstick::sensitivity()}},
\code{\link[yardstick:accuracy]{yardstick::accuracy()}}, \code{\link[yardstick:recall]{yardstick::recall()}}) and not class
probabilities. A set of default metrics is used when \code{NULL} (see
\code{\link[probably:threshold_perf]{probably::threshold_perf()}} for details).}
}
\value{
A \link[tibble:tibble-package]{tibble} with 1 row per threshold. The
columns are:
\itemize{
\item \code{threshold}: The averaged optimal threshold.
\item If \code{weight_by} was specified, an \link[posterior:rvar]{rvar} containing the
distribution of class probability metrics across all samples.
\item A set of \link[posterior:rvar]{rvar} objects for each of the specified
performance metrics, containing the distributions across all samples
(i.e., 1 column per specified metric).
}
}
\description{
Use resampling to estimate an optimal probability classification threshold
when true classifications are unknown.
}
\details{
For each sample requested, a new vector of "true" values is generated using
\code{\link[=generate_truth]{generate_truth()}}. Then, the optimal threshold is calculated for each set of
generated "true" values using the specified \code{optimal_method}.

The final optimal threshold is then calculated the average of the thresholds
that were estimated for each sample. If desired, a distance-weighted mean can
be specified by supplying a class probability metric from the
\link[yardstick:yardstick-package]{yardstick} (e.g., \code{\link[yardstick:roc_auc]{yardstick::roc_auc()}}).
When \code{weight_by} is specified, the chosen metric is computed for the
provided \code{estimates} and each sample of generated "true" values. For example,
we could calculate the area under the ROC curve (AUC) for each sample. The
weight given to each threshold is then determined by the distance of
corresponding AUC values from other AUC values (i.e., give less weight to
outlying metrics).

Finally, the average threshold is applied to each of the generated samples of
"true" values to calculate performance metrics for each resample (e.g.,
sensitivity, specificity). In addition, we can also specify additional
thresholds to compare (\code{comp_thresholds}) that may be of interest (e.g.,
comparing our optimal threshold to the traditional threshold of 0.5). Thus,
the final returned object includes each of the investigated thresholds (i.e.,
the optimal threshold and any specified in \code{comp_thresholds}) and the
distribution of performance metrics across all resamples for each of the
thresholds. To change the metrics that are provided by default, specify new
\code{metrics}.
}
\examples{
est <- runif(100)
optimal_resample(estimates = est, optimal_method = "youden", samples = 200)
}
